\chapter{Diseño de la solución}
\label{chap:diseño}

Como comentamos en el capítulo \ref{chap:introduccion}, el objetivo del trabajo es transformar un servicio monolítico en un sistema distribuido basado en microservicios. Se trata de un cambio arquitectónico importante. Queremos por tanto diseñar una estrategia ingenieril para llevar a a cabo la migración; teniendo en cuenta las particularidades del sistema.

El servicio en cuestión implementa un \textbf{bucle de control MAPE-K}\cite{ibmcorporationArchitecturalBlueprintAutonomic2006,fonsServiciosAdaptivereadyPara2021}, que ya describimos en la sección \ref{sec:bucles-mapek}. Por suerte, partimos de un sistema cuyos componentes presentan una división funcional clara (cada etapa del bucle). Nos facilitará definir las fronteras de nuestros servicios.

Debido a esto, el foco de este capítulo pasará a los \textbf{conectores de \emph{software}}. Necesitamos establecer qué estrategias de comunicación utilizaremos para comunicar los servicios.

\textcolor{red}{Buscar libros de descomposición de monolitos en microservicios.}

\section{Distribución de los componentes}

El primer paso fue identificar los componentes que compondrían nuestra arquitectura. Por suerte, partíamos de un sistema existente, con una arquitectura bien definida y documentada. Conocíamos el rol de cada uno de sus componentes y sus requisitos. Asi que el primer problema al que nos enfrentamos estaba relacionado con la distribución de los servicios. ¿Cómo definimos las fronteras entre cada uno de ellos? ¿Qué componentes debe abarcar cada microservicio?

En la figura \ref{fig:bucle-mapek2} presentamos otra vista de la arquitectura actual del bucle. Una de las decisiones que tomamos muy temprano en el diseño fue separar cada etapa del bucle en su propio servicio. Esto nos aportaba varios beneficios:

\begin{figure}[htb]
  \centering
  \includegraphics[scale=1.15]{cap_introduccion/images/bucle-mape-k}
  \caption[Arquitectura de un Bucle MAPE-K. El flujo de información y de control entre las etapas del bucle están representados con flechas.]{Arquitectura de un Bucle MAPE-K. El flujo de información y de control entre las etapas del bucle están representados con flechas. Obtenida de \cite{fonsEspecificacionSistemasAutoadaptativos2021}}
  \label{fig:bucle-mapek2}
\end{figure}

El más evidente es que nos permitía independizar la implementación de cada etapa. Si fuera necesario, podríamos emplear distintas tecnologías para cada una. Incluso podríamos ofrecer implementaciones alternativas de algunos componentes. Estos podrían ofrecer distintas estrategias de la misma funcionalidad, como podrían ser distintos planificadores. \textcolor{red}{TODO: cita sam newman}

Por otro lado, también nos permitirá escalar cada etapa de forma independiente. Si por ejemplo el servicio de análisis estuviera recibiendo más peticiones que las demás, no sería necesario instanciar el bucle completo. En su lugar, podemos limitarnos a desplegar solo una nueva instancia del componente afectado.

\textcolor{red}{Detectamos otra posible división de funcionalidad:} actualmente, el bucle está muy acoplado al dominio de sus recursos manejados. Todo corre bajo el mismo proceso: el bucle, los monitores, sus reglas de adaptación y demás elementos específicos de la solución. Ese proceso solo podrá manejar aquellos sistemas cuyos módulos tenga cargados.

Decidimos entonces desacoplarlos. Separar cada etapa del bucle MAPE-K de los elementos específicos de cada solución. Así, tendremos cada etapa como un microservicio agnóstico a una solución concreta; y por otro lado, estarán los servicios específicos para cada solución, con conocimiento del dominio del recurso manejado: monitores, reglas de adaptación, efectores\dots

Podremos entonces aprovechar la misma infraestructura para manejar varios sistemas simultáneamente (\emph{multi-tennancy}). \textcolor{red}{ampliar + cita}

En cuanto al despliegue, mantendremos el bucle a nivel de sistema, \cite{mendoncaGeneralityVsReusability2018} como funcionaba hasta ahora. Esto significa que se desplegará conjuntamente con los microservicios del recurso manejado. En la figura \ref{fig:mape-k-microservices} mostramos los microservicios que componen nuestra arquitectura.

\begin{figure}[htb]
  \centering
  \includegraphics[scale=0.25]{cap_diseño/images/mape-k-microservices}
  \caption{Diagrama con los componentes que forman nuestra arquitectura distribuida}
  \label{fig:mape-k-microservices}
\end{figure}

\textcolor{red}{Figura \ref{fig:mape-k-microservices}: Borrar los servicios específicos de planificador y ejecutor. Agrupar los servicios para poder aumentar zoom y hacerlo más legible. Añadir línea de divisón entre la capa del bucle y el dominio del recurso manejado.}

\section{Conectando los servicios}

El siguiente problema al que nos enfrentamos está relacionado con la comunicación: si dividimos estos componentes en microservicios, ¿cómo hacemos para que se comuniquen? Hay que tener en cuenta que estos pueden estar desplegados y replicados en distintas máquinas. No podemos asumir que están en el mismo \emph{host}.

Aprovechando la separación entre bucle de control y el dominio del recurso, investigamos posibles arquitecturas. Nos decantamos por \textbf{arquitecturas de servicios jerarquizados}. Queríamos explotar esta separación para mantener al bucle aislado del dominio de la solución. Dimos con el estilo arquitectónico C2 (\emph {components and connectors})\cite{taylorComponentMessagebasedArchitectural1996a, UCISoftwareArchitecture}, en el que nos hemos inspirado.

\subsection{Jerarquías de microservicios: Arquitectura C2 y arquitectura limpia}

Este estilo organiza sus componentes en jerarquías o capas: cada servicio se encuentra en un nivel determinado, según su nivel de abstracción. En las capas inferiores, se encuentran los servicios más externos, más ''acoplados'' al entorno. Por ejemplo, aquellos servicios que requieran de acceder al sistema de ficheros, estarían en esta capa. Por otro lado, en las capas superiores se encuentran los servicios en niveles de abstracción superior, que dependen lo mínimo del entorno.

En cuanto a la comunicación, un componente solo debe contactar con sus vecinos inmediatos (en una capa superior o inferior). Esto evita que el servicio pueda contactar con otras capas, limitando su alcance y su conocimiento del despliegue del sistema. Además, dentro del mismo nivel no pueden contactar entre ellos. Según la dirección de la comunicación, se emplean mecanismos distintos (figura \ref{fig:C2-arch-example}):

\begin{itemize}
  \item \textbf{Peticiones} (\emph{requests}): Se trata de solicitudes a un servicio para que ejecute una acción. Un componente se comunica directamente con un vecino en una capa superior. La petición viaja de ''fuera hacia dentro'' en cuanto al nivel de abstracción. Por ejemplo, una petición de un cliente a un servicio web podría estar bajo esta categoría.

  \item \textbf{Notificaciones}: Representan eventos ocurridos en el sistema. Un componente de más arriba en la jerarquía (más interno) envía un mensaje hacia abajo, sin especificar receptor. Todos los servicios por debajo lo recibirán, y decidirán si tratarlo o no. Esto evita que nuestro servicio se acople a aquellos que están por debajo (son más concretos). Un ejemplo sería notificar al resto de servicios sobre la creación de un nuevo usuario.
\end{itemize}

\begin{figure}[htb]
  \centering
  \includegraphics[scale=0.45]{cap_diseño/images/c2SampleArch}
  \caption[Ejemplo del estilo arquitectónico C2 (\emph{Components and Connectors})]{Ejemplo del estilo arquitectónico C2 (\emph{Components and Connectors}). \cite{UCISoftwareArchitecture}}
  \label{fig:C2-arch-example}
\end{figure}

Basándonos en este estilo, definimos las capas de nuestro sistema. Esto nos permitió dividir los microservicios en niveles y elegir los conectores más adecuados para cada tipo de comunicación.

Distinguimos cuatro niveles distintos, de menor nivel de abstracción a mayor:

\begin{itemize}
  \item \textbf{Nivel del recurso manejado}: En este nivel se encuentran las sondas y efectores. Son los elementos que tienen más contacto con el recurso manejado. Hacen de intermediarios entre este y el resto del bucle, para reducir su acoplamiento.

  \item \textbf{\textcolor{red}{Nivel de específico solución}}: En esta capa se encuentran componentes del bucle específicos para el dominio del recurso manejado. Monitores específicos, reglas de adaptación... No los incluimos en el mismo nivel que las sondas y efectores porque necesitamos comunicar con ellos. Además que guardan más relación con el bucle que con el recurso manejado.

  \item \textbf{Nivel del bucle}: Aquí se encuentran los servicios de las etapas del bucle: servicio de monitorización, análisis, planificación y ejecución. Esta capa debe ser agnóstica al dominio de los recursos manejados. Además, actúa como intermediario entre los servicios de la solución y el conocimiento. Limitan cómo acceder a él.

  \item \textbf{Conocimiento}: Es la capa más interna y la base de la arquitectura. No depende de ningún otro componente, por lo que tiene el nivel de abstracción más alto. Todos los componentes del nivel del bucle dependen de ella para funcionar.

\end{itemize}

Habiendo definido esta jerarquía, vimos ciertas similitudes con arquitecturas \emph{domain driven}, como \emph{Clean Architecture}. \cite{martinChapter22Clean2018} En ella, el sistema se organiza en base a una \textbf{regla de dependencia}: \emph{''la dependencia entre los componentes solo puede apuntar hacia dentro, hacia políticas de alto nivel''}. Es decir, la arquitectura se organiza en capas concéntricas. En el centro se encuentra el dominio, con el mayor nivel de abstracción. Este no tiene dependencias con ninguna capa exterior. Por otro lado, cada capa más externa tiene dependencias sólo con la capa a la que envuelve. Sólo puede comunicarse con componentes dentro de esta.

Basándonos en la descripción anterior, nuestra capa central será la del conocimiento. A partir de ahí, cada nivel superior dependería de aquel al que ''envuelve'': el bucle al conocimiento, la solución al bucle...Por tanto, para que nuestra arquitectura sea más comprensible, optamos por representarla los diagramas de \emph{Clean Architecture} para representarlo. En la figura \ref{fig:clean-mapek-architecture} mostramos el resultado:

\begin{figure}[htb]
  \centering
  \includegraphics[scale=0.45]{cap_diseño/images/clean-arch-2-MAPEK-style-small}
  \caption[Representación de nuestra propuesta arquitectónica. Inspirado en Arquitectura Limpia (\emph{Clean Architecture}). Las flechas negras representan las peticiones, y las moradas, las notificaciones.]{Representación de nuestra propuesta arquitectónica. Inspirado en Arquitectura Limpia (\emph{Clean Architecture}). Las flechas negras representan las peticiones, y las moradas, las notificaciones. \footnotemark }
  \label{fig:clean-mapek-architecture}
\end{figure}

\footnotetext{Imagen original de arquitectura limpia obtenida de: \url{https://threedots.tech/post/ddd-cqrs-clean-architecture-combined/}}

\subsection{Definiendo los mecanismos de comunicación}

Como comentamos antes, vamos a inspirarnos en los mecanismos de comunicación descritos por C2: las peticiones y notificaciones. Pero, durante nuestra etapa de prototipado, nos dimos cuenta que estos no cubren todas nuestras necesidades. Hay dos casos que no están contemplados: la comunicación del módulo de análisis con el planificador, y la del planificador con el ejecutor. Ambos módulos se encuentran en la misma capa. Y, como dependen del conocimiento, no podemos moverlos a una superior para utilizar notificaciones.

\textcolor{red}{Las notificaciones no nos sirven, ya que la comunicación es entre dos módulos específicos. Aunque nos interesa el desacoplamiento entre módulos que ofrecen. Las peticiones tampoco casan del todo, ya que requerimos desacoplar los módulos. Deberían mantener su independencia en el mayor grado posible.} Por ello, requerimos de un tercer patrón de comunicación. Una combinación de ambos: las peticiones asíncronas.

Los tres patrones de comunicaciones que usaremos entonces son:

\begin{itemize}
  \item \textbf{Peticiones síncronas}: Comunicaciones síncronas dirigidas a un servicio determinado. Solo permitidas entre servicios de una capa más externa a un servicio en la capa interior adyacente.

  \item \textbf{Peticiones asíncronas}: Comunicaciones asíncronas dirigidas a un tipo de servicio determinado. Se trata de peticiones de trabajo asíncronas: se envían y el destinatario lo procesará cuando pueda. El cliente continuará su ejecución, sin esperar respuesta. \emph{fire and forget}.

  Para evitar el acoplamiento entre los componentes, deberemos buscar un conector que permita enviar el mensaje sin conocer específicamente al destinatario.

  Este mecanismo de comunicación solo está permitido entre elementos del mismo nivel.

  \item \textbf{Notificaciones}: Comunicaciones asíncronas no dirigidas. El servicio publica un evento que potencialmente recibirán todos los servicios en la capa exterior adyacente. El cliente lo envía y continua su ejecución, sin esperar respuesta.
\end{itemize}

\subsection{Conectores}

Una vez determinadas las necesidades de comunicación de nuestro sistema, debemos buscar los conectores adecuados. Seguimos la estrategia descrita en \cite{taylorSoftwareArchitectureFoundations2009} para elegir conectores; y nos basamos en los patrones de comunicación en sistemas distribuidos descritos en \cite{newmanBuildingMicroservicesDesigning2021}.

Comenzamos investigando las peticiones síncronas. Tomemos por ejemplo la comunicación entre el servicio de monitorización (\emph{monitoring service}) y el servicio de conocimiento (\emph{knowledge service}). Recordemos que el servicio de conocimiento almacena todas las propiedades de adaptación. El resto de servicios necesitan consultarlas y actualizarlas durante su funcionamiento. En la figura \ref{fig:monitor-knowledge-initial} representamos inicialmente ambos componentes y un conector, sin especificar de qué tipo será.

% TODO: Cambiar por imagen de componentes, que ofrezcan y requieran interfaces.
\begin{figure}[htb]
  \centering
  \includegraphics{cap_diseño/images/Monitor-Knowledge-Initial-Connector}
  \caption{Boceto inicial: queremos conectar el servicio de monitorización con la base de conocimiento para poder leer propiedades de adaptación.}
  \label{fig:monitor-knowledge-initial}
\end{figure}

El siguiente paso es identificar qué interacciones debe existir entre ambos componentes. En este caso, el servicio de monitorización debe contactar con el servicio de conocimiento para leer y actualizar el valor de las propiedades.Por tanto, existen operaciones de lectura y escritura de los datos. Además, como es una comunicación ''descendente'' (\emph{monitoring service} está en la capa superior), el patrón a utilizar serán las peticiones síncronas.

Ahora, debemos identificar qué \textbf{tipos de conector} serían adecuados para este patrón. Sabiendo que hemos optado por una arquitectura distribuida, la elección se simplifica: los servicios pueden estar desplegados en máquinas distintas, por tanto el paso de mensajes será a través de la red.

Conociendo esto, en lugar de recurrir a la taxonomía que lista \cite{mehtaTaxonomySoftwareConnectors2000}, optamos por consultar las estrategias de comunicación habituales para sistemas distribuidos descritas en \cite{newmanBuildingMicroservicesDesigning2021}. Se trata de cuatro mecanismos distintos: Invocación a métodos remotos (\emph{Remote Procedure Call}), APIs REST, consultas con GraphQL o \emph{brokers} de mensajería. Tuvimos que evaluarlos mediante un análisis de \emph{trade-offs} para determinar las ventajas y desventajas de cada uno.

\textcolor{red}{Smart endpoints, dumb pipes: https://simplicable.com/new/smart-endpoints-and-dumb-pipes}

\textbf{Invocación de métodos remotos} o (\emph{\textbf{Remote Procedure Call}}): Esta patrón se basa en el estilo cliente-servidor. Un servidor expone una serie de funciones que el cliente puede invocar mediante peticiones a través de la red. Estas peticiones incluyen el nombre de la función a ejecutar y sus parámetros. Al finalizar la ejecución, el servidor puede devolver su resultado, si lo hubiera. Existen varios protocolos que implementan este mecanismo como gRPC o SOAP.

Una evolución de RPC suele emplearse en la programación orientada a objetos: el paradigma de \textbf{objetos distribuidos}. \cite{tanenbaumChapter10Distributed2007} En este caso, el programa cliente puede interactuar con objetos en servidores remotos como si fueran locales. Esta interacción se realiza a través de objetos que actúan como \emph{proxies}, abstrayendo de la llamada al servidor.

Los \emph{proxies} ofrecen una interfaz para que el cliente invoque sus métodos localmente. Internamente, estos métodos realizan una llamada al servicio remoto donde se encuentra el objeto realmente. El servidor remoto procesa la petición y nos devolverá un resultado. Así, abstraen al cliente de todo este proceso de comunicación. En la figura \ref{fig:rpc-distributedobjects} tenemos un esquema de este mecanismo.

\begin{figure}[htb]
  \centering
  \includegraphics[scale=1.5]{cap_diseño/images/rpc-distributedobjects}
  \caption[Funcionamiento del sistema de objetos distribuidos]{Funcionamiento del sistema de objetos distribuidos. \cite{tanenbaumChapter10Distributed2007}}
  \label{fig:rpc-distributedobjects}
\end{figure}

\begin{itemize}
  \item \textbf{Ventajas}:
  \begin{itemize}
    \item Permite distribuir la carga de procesamiento del sistema. Esto puede ayudar para escalar la aplicación.

    \item Abstrae al cliente de la interacción con un servidor remoto. Le resulta prácticamente indistinguible de un objeto local.

    \item \textcolor{red}{Los \emph{proxies} o (\emph{stubs} en la terminología de RPC) suelen generarse a partir de un contrato que define qué operaciones ofrecen estos objetos. Por ejemplo: SOAP con WDSL, gRPC; o en el caso de objetos distribuidos, Java RMI.} ¿Y la ventaja?
  \end{itemize}

  \item \textbf{Desventajas}:
  \begin{itemize}
    \item No se puede abstraer completamente al cliente de las llamadas a través de la red. Pueden darse errores que no ocurrirían durante una invocación de un método sobre un objeto local. Por ejemplo, que el servidor no esté disponible. \cite{jausovecFallaciesDistributedSystems2020}

    \item Dificulta la integración con otras aplicaciones. Cada servicio ofrece sus propias funciones distintas. No están estandarizadas.

    \item Si adoptamos sistemas como Java RMI, nuestro sistema se acopla a esa tecnología concreta. \cite{newmanBuildingMicroservicesDesigning2021}. Nos quita flexibilidad en cuanto a qué otras tecnologías podemos utilizar en nuestra arquitectura.

    \item El cliente debe actualizarse y recompilarse con cada cambio en el esquema del servidor. Esto puede ser problemático para casos donde tenemos que desplegar una actualización para que nuestros clientes puedan continuar utilizando la aplicación.
  \end{itemize}
\end{itemize}

\textbf{\emph{Representational State Transfer} (REST)}: Se basa también en el estilo arquitectónico cliente-servidor, pero con ciertas restricciones adicionales. \cite{taylorSoftwareArchitectureFoundations2009} Su concepto principal son los \textbf{recursos}: cualquier elemento sobre el que la API pueda ofrecernos información; y que pueda tener asociado un identificador único (una URI). \cite{richardsonRESTfulWebServices2007} Por ejemplo, podrían ser las entidades del dominio que gestiona nuestro servicio: usuarios, mediciones de temperaturas\dots

Las acciones que podemos ejecutar sobre los recursos (leer, crear, actualizar, \dots) las define el protocolo de comunicación sobre el que se implemente. Gracias a esto, la API que pueden ofrecer los servicios REST es común. Solo cambia el ``esquema de los datos``, los tipos de recursos que ofrecen. Esto facilita enormemente la integración con otros servicios. \cite{nallyRESTVsRPC2018} La implementación más habitual es sobre el protocolo HTTP. Define métodos estandarizados como \emph{GET} para las lecturas, \emph{PUT} para las actualizaciones, etc.

\begin{itemize}
  \item \textbf{Ventajas}:

  \begin{itemize}
    \item \textbf{\emph{Stateless}}: El servidor no mantiene el estado de la sesión del cliente. Esto permite que cada petición sea independiente de las demás.

    \item \textbf{Escalable}: Como las sesiones deben ser \emph{stateless}, podremos replicar nuestro servicio y que distintas instancias puedan atender las peticiones que surjan durante una misma sesión.

    \item \textbf{API Sencilla}: Solo hay que implementar unos pocos métodos estándar para interactuar con la API.

    \item \textbf{Comunicación síncrona}: Es el mecanismo ideal para comunicaciones síncronas, donde el cliente requiere la respuesta del servicio para poder continuar con su procesamiento. También podemos dar soporte a para comunicaciones \emph{fire and forget}, donde el cliente envía un mensaje y no espera ninguna respuesta a su petición.

    \item \textbf{Interoperabilidad}: Ampliamente utilizado en servicios de Internet. Es ideal para que clientes externos contacten con nuestro sistema mediante peticiones síncronas. \cite{newmanBuildingMicroservicesDesigning2021}

    \item \textbf{Generación de clientes}: Para facilitar la comunicación con APIs REST, podemos generar librerias cliente utilizando el estándar OpenAPI. Lo explicaremos con maś detalle en la sección \ref{chap:OpenAPI}.
  \end{itemize}

  \item \textbf{Desventajas}:

  \begin{itemize}
    \item \textbf{Dirigida}: Necesitamos conocer de antemano la ubicación del servidor al que queremos hacer una petición.

    \item \textbf{Rendimiento}: El rendimiento es peor comparado con mecanismos RPC. El tamaño de un mensaje HTTP serializado en XML o JSON es mayor que si estuviera en un formato binario.

    \item \textbf{API Sencilla}: También es una desventaja. Hay operaciones complejas que pueden ser difíciles de representar con los métodos ofrecidos por el protocolo de comunicación. Pueden requerir más tiempo de diseño, o incluso, ser implementados siguiendo el patrón RPC.
  \end{itemize}
\end{itemize}

\textbf{GraphQL}\footnote{Página oficial: \url{https://graphql.org/}} \textcolor{red}{AMPLIAR}: Se trata de un protocolo de consultas. Permite a los clientes ejecutar consultas personalizadas sobre los datos de un servidor. No necesitan de lógica específica para ejecutarla. De esta forma, el cliente puede obtener toda la información que necesita. Reduce el número de peticiones ejecutadas. También evita traerse datos innecesarios.

\begin{itemize}
  \item \textbf{Ventajas}:

  \begin{itemize}
    \item \textbf{Ideal para móviles}: Gracias a que reduce la cantidad de llamadas, es ideal para entornos donde queremos optimizar el uso de red.

    \item \textbf{Rendimiento}: Ofrece un mayor rendimiento comparado con otras alternativas que no ofrezcan un endpoint ya implementado. Y debamos obtener la misma información por composición, haciendo varias llamadas.
  \end{itemize}

  \item \textbf{Desventajas}:

  \begin{itemize}
    \item \textbf{Solo permite lecturas}: Es un lenguaje de consultas. No tiene comandos que permita escrituras.

    \item \textbf{Solo permite lecturas síncronas}:

    \item \textbf{Exponemos datos a la red}:

    \item \textbf{Problemas de rendimiento}: El cliente puede hacer consultas muy pesadas que penalicen el rendimiento de la base de datos sobre la que opera nuestro servicio.
  \end{itemize}
\end{itemize}

\textbf{\foreign{english}{Brokers} de mensajería}: Es un mecanismo de \textbf{comunicación asíncrona} muy popular. Sobre todo en arquitecturas basadas en eventos. Contamos con un servicio que actúa como intermediario, el \emph{broker}. Este gestiona la comunicación entre los servicios del sistema. \cite{newmanBuildingMicroservicesDesigning2021} Hay varias estrategias de comunicación posibles: colas de trabajo, \emph{publish-suscribe}, híbrida\dots

Tomemos por ejemplo las \textbf{colas de trabajo}. \cite{royChapterMessagePatterns2017} Es una estrategia para implementar comunicaciones asíncronas dirigidas. Nos permiten desacoplar la comunicación entre componentes usando colas de mensajería como intermediarias. Para ello, un servicio, el productor, publica mensajes en la cola. Estos mensajes representan peticiones de trabajo que pueden ser costosas de procesar. Un servicio, el trabajador, estará la escucha de los mensajes que llegan y los irá consumiendo. Estos mensajes se procesan siguiendo un orden FIFO (\emph{first in, first out}). En la figura \ref{fig:work-queues} mostramos un ejemplo con dos consumidores, a la escucha de la misma cola.

\begin{figure}[htb]
  \centering
  \includegraphics[scale=0.65]{cap_diseño/images/work-queues}
  \caption[Representación de las colas de trabajo. Ejemplo de comunicación asíncrona dirigida.]{Representación de las colas de trabajo. Ejemplo de comunicación comunicación asíncrona dirigida. \footnotemark }
  \label{fig:work-queues}
\end{figure}

\footnotetext{Imagen obtenida de: \url{https://www.rabbitmq.com/tutorials/tutorial-two-dotnet.html}}

Otra estrategia posible es \foreign{english}{publish-suscribe}: sirve para implementar comunicación \emph{multicast}. Se basa en el uso de \textbf{temas} o \textbf{\foreign{english}{topics}}: categorías de mensajes que pueden resultar de interés. Un servicio (el productor) envía un mensaje al \foreign{english}{broker}, indicando que pertenece a un tema determinado. El \emph{broker} recibe el mensaje y se encarga de reenviarlo a todos los servicios subscritos a este tema en concreto. \cite{rabbitmqPublishSubscribeDocumentation} En la figura \ref{fig:publish-subscribe} tenemos un ejemplo de esta estrategia.

\textcolor{red}{Describir fanout}
\textcolor{red}{Describir exchanges}

\begin{figure}[htb]
  \centering
  \includegraphics[scale=0.5]{cap_diseño/images/publish_subscribe}
  \caption[Estrategia \emph{publish/suscribe}: el \emph{broker} actúa como intermediario en la comunicación \emph{multicast}.]{Estrategia \emph{publish/suscribe}: el \emph{broker} actúa como intermediario en la comunicación \emph{multicast}. Imagen obtenida de \footnotemark}
  \label{fig:publish-subscribe}
\end{figure}

\footnotetext{Java Messaging Service: \url{https://docs.oracle.com/cd/E19509-01/820-5892/ref_jms/index.html}}

La mayor ventaja de este estilo de comunicación es el \textbf{desacoplamiento} entre los servicios. \cite{korabUnderstandingMessageBrokers2017}
Ninguno de ellos necesita conocer detalles sobre cómo están desplegado los otros: su dirección, el número de instancias, si están activos en este momento, etc. Solo necesitan conocer el formato de los mensajes y la dirección del \emph{broker} para enviarlos o recibirlos.

\begin{itemize}
  \item \textbf{Ventajas}:

  \begin{itemize}
    \item \textbf{Comunicación asíncrona}: El servicio no necesita quedarse a la espera de una respuesta del servidor. Puede procesar otras operaciones hasta que se le notifique del resultado, si lo hubiera.

    \item \textbf{Desacoplamiento de los servicios}: Ni los productores ni los consumidores necesitan conocer el origen o destino de sus mensajes. Solo su formato y la dirección del \emph{broker}.

    \item \textbf{Envío garantizado de mensajes}: El \emph{broker} garantiza que el mensaje será entregado \emph{al menos} una vez al consumidor. Reintentará el reenvío hasta que se confirme su recepción.

  \end{itemize}

  \item \textbf{Desventajas}:

  \begin{itemize}
    \item \textbf{Requisitos de infraestructura}: Utilizar un \emph{broker} de mensajería puede incrementar la dificultad de nuestros despliegues. El \emph{broker} puede convertirse en un punto de fallo. Para operar de forma fiable, estos sistemas requieren de replicación. \cite{newmanBuildingMicroservicesDesigning2021}

    \item \textbf{Envío garantizado de mensajes}: Para poder garantizar el envío de un mensaje, el \emph{broker} puede recurrir a reenviarlo. Debemos diseñar nuestros sistemas de forma que estos mensajes duplicados sean descartados si ya han sido procesados.
  \end{itemize}
\end{itemize}

En la tabla \ref{tab:comparativa-mecanismos-comunicacion} presentamos un resumen de esta comparativa:

\begin{longtable}{|p{4.4cm} | c | c | c | c|}
  \hline
  & \textbf{RPC} & \textbf{REST} & \textbf{GraphQL} & \textbf{Broker mensajería} \\
  \hline
  \textbf{Tipo de comunicación entre componentes} & Directa & Directa & Directa & Directa y \emph{Multicast} \\
  \hline
  \textbf{Acoplamiento entre componentes} & Alto & Medio & Alto & Bajo \\
  \hline
  \textbf{Interoperabilidad} & Baja & Alta & Alta & Alta\footnotemark \\
  \hline
  \textbf{Comandos de lectura} & Sí & Sí & Sí & Sí \\
  \hline
  \textbf{Comandos de escritura} & Si & Sí & No & Sí \\
  \hline
  \textbf{Comunicación síncrona} & Sí & Sí & Sí & No \\
  \hline
  \textbf{Comunicación asíncrona} & No & Sí & No & Si \\
  \hline
  \caption{Comparativa de los mecanismos de comunicación.}
  \label{tab:comparativa-mecanismos-comunicacion}
\end{longtable}

\footnotetext{Depende de si tenemos control sobre los componentes que queremos integrar.}


--------------------------------------------------------------

Ahora analizaremos qué protocolo elegimos para cada mecanismo de comunicación.

\subsection{Peticiones síncronas}

De estas cuatro opciones, podemos descartar inmediatamente la opción de GraphQL. Se trata de un conector más orientado a las consultas de datos. En nuestro caso, necesitamos ejecutar también escrituras de los valores de las propiedades. Aunque podría ser interesante para consultas más avanzadas, utilizar dos protocolos de comunicación en paralelo aumentaría la complejidad de la arquitectura.

También optamos por descartar el \emph{broker} de mensajería. Como requerimos de comunicación directa, nos convenía que esta fuera síncrona. Para obtener propiedades del conocimiento, resultaba más sencillo de implementar mediante comunicación síncrona.

Finalmente, hay que tener en cuenta que una de nuestras prioridades es la \textbf{interoperabilidad}: es una API expuesta ''hacia fuera'', hacia una capa más externa; prima por tanto la compatibilidad con cualquier tipo de cliente. Descartamos entonces RPC, dado que nos acoplaría a una tecnología concreta y a APIs no estándares.

Terminamos por tanto decantándonos por implementar la comunicación utilizando un conector REST sobre HTTP. Implementaremos ambas funciones mediante \emph{endpoints} HTTP. Su especificación se detalla a continuación en las tablas \ref{tab:especificacion-get-property} y \ref{tab:especificacion-put-property}.

\newsavebox\getpropertyrequestbox
\begin{lrbox}{\getpropertyrequestbox}
  \begin{minipage}[t]{1in}
    \begin{verbatim}
Request:
HTTP GET property/currentTemperature

Response: 200 Ok
{
  value: {
    "Value":16.79,
    "Unit": 1, // Celsius
    "ProbeId":"c02234d3-329c-4b4d-aee0-d220dc25276b",
    "DateTime":"2022-01-15T18:19:38.5231231Z"
  },
  lastModification: "2022-01-15T18:19:39.123213Z"
}
    \end{verbatim}
  \end{minipage}
\end{lrbox}

\begin{table}[htb]
  \centering

  \begin{tabular}{|m{3.4cm}|p{2.5cm}|p{1cm}|p{3cm}|}
      \hline

      \textbf{Operación HTTP} & GET & \textbf{Ruta} & property/\{\emph{propertyName}\} \\
      \hline

      \textbf{Descripción} & \multicolumn{3}{|l|}{Devuelve el valor de la propiedad, si existe.} \\
      \hline

      \textbf{Parámetros} & \emph{propertyName} & \multicolumn{2}{|m{0.55\linewidth}|}{El nombre de la propiedad que deseamos obtener. Se lee a partir de la ruta de la petición.}\\
      \hline

      \multirow{3}*{\textbf{Respuestas posibles}}
            & \textbf{Código 200 (Ok)} & \multicolumn{2}{|m{0.55\linewidth}|}{La propiedad se ha encontrado. Incluye un \emph{payload} con el siguiente esquema:

            \begin{itemize}
              \item \emph{Value}: Valor de la propiedad serializado en JSON.
              \item \emph{LastModification}: Fecha y hora de la última modificación de esta propiedad.
            \end{itemize}}\\

            \cline{2-4}

            & \textbf{Código 400 (Bad request)} & \multicolumn{2}{|m{0.55\linewidth}|}{La petición está mal formada, no es acuerdo al contrato.}\\

            \cline{2-4}

            & \textbf{Código 404 (Not found)} & \multicolumn{2}{|m{0.55\linewidth}|}{No se ha encontrado ninguna propiedad con el nombre proporcionado.}\\
      \hline

      \textbf{Ejemplo} & \multicolumn{3}{|b{0.7\linewidth}|}{Petición para obtener la propiedad \emph{currentTemperature}:
      \usebox\getpropertyrequestbox} \\

      \hline
  \end{tabular}

  \caption{Especificación de la operación para obtener una propiedad del servicio de conocimiento.}
  \label{tab:especificacion-get-property}
\end{table}

\newsavebox\putpropertyrequestbox
\begin{lrbox}{\putpropertyrequestbox}
  \begin{minipage}[t]{2in}
    \begin{verbatim}
Request:
HTTP PUT property/currentTemperature

{
  value: {
    "Value":16.79,
    "Unit": 1, // Celsius
    "ProbeId":"c02234d3-329c-4b4d-aee0-d220dc25276b",
    "DateTime":"2022-01-15T18:19:38.5231231Z"
  }
}

Response: 204 (No content)
        \end{verbatim}
  \end{minipage}
\end{lrbox}

\begin{table}[htb]
  \centering

  \begin{tabular}{|m{3.4cm}|m{2.5cm}|b{1cm}|b{3cm}|}
      \hline

      \textbf{Operación HTTP} & PUT & \textbf{Ruta} & property/\{\emph{propertyName}\} \\
      \hline

      \textbf{Descripción} & \multicolumn{3}{|b{0.7\linewidth}|}{ Actualiza (o crea, si no existe) el valor de la propiedad con el nombre dado.} \\
      \hline

      \multirow{2}*{\textbf{Parámetros}}
            & \emph{propertyName} & \multicolumn{2}{|b{0.55\linewidth}|}{El nombre de la propiedad que deseamos crear o actualizar. Se lee a partir de la ruta de la petición.}\\

            \cline{2-4}

            & \emph{SetPropertyDTO} & \multicolumn{2}{|b{0.55\linewidth}|}{ Un DTO que contiene el valor a asignar en la propiedad serializado en JSON. El DTO se encuentra en el cuerpo de la petición.} \\
      \hline

      \multirow{2}*{\textbf{Respuestas posibles}}
            & \textbf{Código 204 (No content)} & \multicolumn{2}{|b{0.55\linewidth}|}{La propiedad se ha creado o actualizado correctamente. No incluye \emph{payload} en el cuerpo de la respuesta.}\\

            \cline{2-4}

            & \textbf{Código 400 (Bad request)} & \multicolumn{2}{|b{0.55\linewidth}|}{La petición está mal formada, no es acuerdo al contrato.}\\
      \hline

      \textbf{Ejemplo} & \multicolumn{3}{|b{0.7\linewidth}|}{Petición para actualizar la propiedad \emph{currentTemperature} con una medición de un termómetro:
      \usebox\putpropertyrequestbox} \\

      \hline
  \end{tabular}

  \caption{Especificación de la operación para actualizar o crear una propiedad del servicio de conocimiento.}
  \label{tab:especificacion-put-property}
\end{table}

Una vez definida la interfaz que expondrá el servicio de conocimiento, nos queda definir cómo se contactará desde el servicio de monitorización. ¿Implementamos las llamadas manualmente con un cliente HTTP? Aunque no sería muy complicado, tendríamos que mantenerlo manualmente cuando evolucione el sistema. Optamos entonces por una alternativa: el estándar OpenAPI.

\subsubsection{Open API}
\label{chap:OpenAPI}

\begin{wrapfigure}{r}{0.3\linewidth}
  \vspace{5pt}
  \includegraphics[scale=0.32]{cap_diseño/images/openapi-logo}
  \centering
  \vspace{5pt}
\end{wrapfigure}

OpenAPI es un lenguaje estándar para describir APIs RESTful. Nos permite describir de forma estructurada las operaciones que ofrece un servicio HTTP, manteniéndose agnóstico a su implementación. Esta descripción ayuda tanto a humanos como a computadoras a descubrir y utilizar las funcionalidades de la API. La OpenAPI Initiative (OAI) dirige el proyecto bajo el manto de la \emph{Linux Foundation}.

Un documento OpenAPI habitual documenta el funcionamiento de la API y el conjunto de recursos que la componen. Describe las operaciones HTTP que podemos ejecutar sobre estos recursos, incluyendo las estructuras de datos que recibe o envía y los códigos de respuesta. Estos códigos indican al cliente el resultado de la ejecución de la operación. \cite{openapi_initiativeOpenAPISpecificationV3} Más adelante mostraremos un ejemplo, con el \textcolor{red}{fragmento} \ref{ls:openapi-get}.

La especificación puede escribirse manualmente o puede generarse a partir de una implementación existente. Así, podemos desarrollar nuestro servicio en un determinado lenguaje y obtener su descripción en OpenAPI. Podemos aprovecharla en varios ámbitos del desarrollo, gracias a la gran variedad de herramientas existentes: generación de documentación, generación de casos de prueba, identificar cambios incompatibles, etc. \cite{westerveldChapterOpenAPIAPI2021}

Uno de los casos de uso más interesantes es la generación de código a partir de la definición. Existen una serie de generadores\footnote{\url{https://github.com/OpenAPITools/openapi-generator}} capaces de generar clientes o servidores conformes a la especificación. Ofrecen soporte a una gran variedad de lenguajes: Java, C\#, JavaScript\dots En el caso de cliente, actúa como un proxy que nos abstrae de la lógica de comunicación con el servidor, similar a lo descrito en el apartado de RPC.

Para el desarrollo de este trabajo, nos interesaba especialmente debido a las diferencias tecnológicas existentes: el bucle MAPE-K original estaba desarrollado en Java, pero el prototipo se desarrolló con el lenguaje C\# junto con el framework ASP.NET Core. Se tomó esta decisión para reducir el tiempo de aprendizaje y centrar los esfuerzos en la definición de la arquitectura del sistema.

\textcolor{red}{Gracias a la generación de código, pudimos obtener la especificación de los servicios desarrollados en ASP.NET Core, y generar clientes o servidores en cualquier lenguaje soportado, Java incluido. El bucle MAPE-K original después podría ser refactorizado usando este código autogenerado.}

A continuación explicaremos brevemente cómo utilizamos OpenAPI para documentar nuestras APIs y generar la especificación estas. Para ello, continuaremos con el ejemplo del servicio de conocimiento que hemos descrito a lo largo de este capítulo. Vamos a centrarnos en la implementación de la operación para obtener una propiedad del conocimiento, que describimos en la tabla \ref{tab:especificacion-get-property}.

En el \textcolor{red}{fragmento} \ref{ls:csharp-get}, podemos observar que se trata de un método C\# llamado \emph{GetProperty}. Su implementación es sencilla: busca en un diccionario la propiedad cuyo nombre se le pasa por parámetro. En caso de encontrarla, devuelve su valor con un código 200 OK. En caso contrario, devuelve un código de error que describe qué ha ocurrido exactamente (llamada incorrecta o no se ha encontrado la propiedad).

Aparte de la implementación, podemos comprobar que el método se ha decorado con una serie de comentarios (líneas 1-8) y atributos (10-12). Esta documentación describe qué hace el método, sus entradas y posibles respuestas. OpenAPI es capaz de utilizar estos elementos opcionales para generar una especificación más completa. Por tanto, resulta muy recomendable utilizarlos.

\begin{lstlisting}[language={[Sharp]C},caption={Implementación del método GetProperty decorado para generar la especificación OpenAPI.},captionpos=b, label=ls:csharp-get]
/// <summary>
///    Gets a property given its name.
/// </summary>
/// <param name="propertyName"> The name of the property to find. </param>
/// <returns> An IActionResult with result of the query. </returns>
/// <response code="200"> The property was found. Returns the value of the property. </response>
/// <response code="404"> The property was not found. </response>
/// <response code="400"> There was an error with the provided arguments. </response>
[HttpGet("{propertyName}")]
[ProducesResponseType(typeof(PropertyDTO), StatusCodes.Status200OK)]
[ProducesResponseType(StatusCodes.Status404NotFound)]
[ProducesResponseType(StatusCodes.Status400BadRequest)]
public IActionResult GetProperty([FromRoute]string propertyName)
{
    if (string.IsNullOrEmpty(propertyName))
    {
        return BadRequest();
    }

    bool foundProperty = properties.TryGetValue(propertyName, out PropertyDTO property);

    if (!foundProperty)
    {
        return NotFound();
    }

    return Ok(property);
}
\end{lstlisting}

Haciendo uso de las librerías de OpenAPI, generamos la especificación a partir del servicio de conocimiento. En el \textcolor{red}{fragmento} \ref{ls:openapi-get}, podemos ver cómo se describe la operación en este estándar:

\begin{lstlisting}[language=python,caption={Especificación OpenAPI del método para obtener una propiedad del conocimiento (\lstinline{GetProperty}).},captionpos=b, label=ls:openapi-get]
"paths": {
  "/Property/{propertyName}": {
    "get": {
      "tags": [
        "Property"
      ],
      "summary": "Gets a property given its name.",
      "parameters": [
        {
          "name": "propertyName",
          "in": "path",
          "description": "The name of the property to find.",
          "required": true,
          "schema": {
            "type": "string"
          }
        }
      ],
      "responses": {
        "200": {
          "description": "The property was found. Returns the value of the property.",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PropertyDTO"
              }
            }
          }
        },
        "404": {
          "description": "The property was not found.",
        },
        "400": {
          "description": "There was an error with the provided arguments.",
        }
      }
    }
  }
\end{lstlisting}

Podemos apreciar que en la ruta (\emph{/Property/\{propertyName\}}) está disponible una operación de tipo \emph{get} y que acepta determinados parámetros y ofrece unas posibles respuestas. Aparece una referencia a otro esquema (línea 25), que representa la estructura de la respuesta en ese caso concreto. También aparecen los comentarios opcionales que indicamos en el \textcolor{red}{fragmento} \ref{ls:csharp-get}. Encontramos grandes similitudes con la especificación presentada en la tabla \ref{tab:especificacion-get-property}.

Los convenios de los generadores de código de OpenAPI pueden no ser de nuestro agrado. Por ejemplo, pueden resultar muy verbosos o puede resultar muy pesado trabajar con DTOs directamente. Por suerte, tenemos dos opciones para solventar esto: Modificar las plantillas de generación de código. Al ser de código abierto, podríamos modificar las existentes o crear nuestras propias plantillas con nuestros propios convenios.

Otra opción, más fácil de implementar, es desarrollar código por encima del API Client Generado. Es el caso del servicio de Análisis. Como trabajar con DTOs directamente se hacía muy pesado, optamos por implementar un `system configuration request` builder. Esto nos permitia configurar la petición de una forma más descriptiva para el usuario:

\begin{lstlisting}[language={[Sharp]C},caption={Implementación de la misma petición siguiendo el patrón \emph{builder}.},captionpos=b, label=ls:api-cliente-request-builder]
var changeRequests = new List<ServiceConfigurationDTO>
{
  new()
  {
    ServiceName = ClimatisationAirConditionerConstants.AppName,
    IsDeployed = true,
    ConfigurationProperties = new List<ConfigurationProperty>()
    {
      new()
      {
          Name = ClimatisationAirConditionerConstants.Configuration.Mode,
          Value = AirConditioningMode.Cooling.ToString(),
      },
    },
  },
};

var symptoms = new List<SymptomDTO> { new(SymptomName, "true") };

var systemConfigurationChangeRequest = new SystemConfigurationChangeRequestDTO()
{
  ServiceConfiguration = changeRequests,
  Symptoms = symptoms,
  Timestamp = DateTime.UtcNow,
};

await _systemApi.SystemRequestChangePostAsync(
  systemConfigurationChangeRequest,
  CancellationToken.None);
\end{lstlisting}


\begin{lstlisting}[language={[Sharp]C},caption={Implementación de la misma petición siguiendo el patrón \emph{builder}.},captionpos=b, label=ls:api-cliente-request-builder]
await _systemService.RequestChangeAsync(changeRequest =>
{
  changeRequest
    .ForSymptom(TemperatureGreaterThanHotThreshold)
    .WithService(ClimatisationAirConditionerConstants.AppName, service =>
    {
      service.MustBePresent()
        .WithParameter(
          ClimatisationAirConditionerConstants.Configuration.Mode,
          AirConditioningMode.Cooling.ToString());
    });
});
\end{lstlisting}

Finalmente, la arquitectura del conector que emplearemos para implementar las peticiones aparece en la figura \ref{fig:monitor-knowledge-connector-architecture}. La figura muestra como el servicio de monitorización contacta al de conocimiento para asignarle un valor a la propiedad \emph{Temp}.

El conector, delimitado por una línea discontinua roja, está compuesto por dos elementos: una API REST y un cliente. Los otros dos grupos de elementos representan los procesos de los servicios de monitorización y conocimiento. El servicio de monitorización se comunica a con la API través del API Client, que está en su proceso actuando como \emph{proxy}.

%%% TODO: Actualizar la imagen para que aparezca PUT en vez de POST.
%%% TODO: ¿Darle la vuelta a los servicios? Monitor arriba y Knowledge abajo.
\begin{figure}[h!]
  \centering
  \includegraphics[scale=0.64]{cap_diseño/images/Monitor-Knowledge-Connector}
  \caption{Diseño del conector usando implementación Cliente - Servidor}
  \label{fig:monitor-knowledge-connector-architecture}
\end{figure}

\pagebreak

\subsection{Notificaciones}

El siguiente mecanismo de comunicación a definir son las notificaciones. Recordemos que esta comunicación es desde un servicio a todos los que se encuentren en la capa superior (\emph{multicast}). No debe estar acoplada a ningún servicio concreto. Potencialmente, todos deberían recibir el mensaje y decidir si procesarlo o no.

Como ejemplo, tomaremos la comunicación entre el servicio de conocimiento y los servicios en la capa superior (el nivel del bucle). Cada vez que se modifique una propiedad o una configuración de un servicio, el servicio emitirá un evento notificando del cambio a la capa superior. Así, por ejemplo, el servicio de análisis sabrá que debe reevaluar las reglas de adaptación.

Sabiendo esto, podemos descartar de entrada GraphQL. Es un protocolo basado en lecturas. Como el objetivo es enviar información a otros servicios, no nos sirve. Respecto a RPC y REST, tampoco nos sirven, no tienen un buen soporte de multicast. Además de que tenemos el requisito de bajo acoplamiento.

Por tanto, optamos por implementarlo usando un \emph{broker} de mensajería. Concretamente, siguiendo el patrón \emph{publish}-\emph{subscribe}. El servicio de conocimiento publicará el evento a través del \emph{broker} de mensajería. Este evento tendrá un \emph{topic} asociado. Todos los servicios interesados deberán suscribirse a este \emph{topic}. El \emph{broker} reenviará el mensaje a una cola específica para cada uno de los servicios suscritos al tema. Así podrán procesarlo cuando puedan, de forma asíncrona.

De esta manera logramos el desacoplamiento de los componentes y permitimos el procesamiento asíncrono de estos eventos.

Aunque potencialmente otros servicios podrían suscribirse a estos cambios, vamos a centrarnos en la suscripción del módulo de análisis.

Los eventos incluirán la información mínima indispensable. En este caso, el nombre de la propiedad que ha cambiado. Esta decisión la tomamos así debido a que es una comunicación asíncrona. Si el evento incluyera el valor de la propiedad y se procesa mucho más tarde, podría derivar en adaptaciones Así evitamos una adaptación incorrecta del sistema. Para evitarlo, incluyendo solo el nombre de la propiedad, obligamos a las reglas a que soliciten el valor de la propiedad en el momento en que se evaluen. Así siempre se ejecutaran con la información actualizada.

El evento que publicaría el módulo de conocimiento cuando cambia una propiedad podría ser como el siguiente (tabla \ref{tab:especificacion-property-changed-integrationevent}):

\newsavebox\propertychangedeventbox
\begin{lrbox}{\propertychangedeventbox}
  \begin{minipage}[t]{2in}
    \begin{verbatim}
{
  "PropertyName":"Temperature"
}
        \end{verbatim}
  \end{minipage}
\end{lrbox}

\begin{table}[htb]
  \centering

  \begin{tabular}{|m{2.3cm}|p{2.5cm}|p{2.6cm}|b{1.5cm}|b{1.5cm}|}
      \hline

      \textbf{Evento} & \multicolumn{2}{|b{0.35\linewidth}|}{\emph{PropertyChangedIntegrationEvent }} & \textbf{\emph{Exchange}} & \emph{AdaptionLoop.Knowledge}  \\
      \hline

      \textbf{Descripción} & \multicolumn{4}{|b{0.6\linewidth}|}{Evento de integración que notifica sobre el cambio de una propiedad adaptación.} \\
      \hline

      \textbf{Propiedades}
            & \emph{propertyName} & \multicolumn{3}{|b{0.6\linewidth}|}{Nombre de la propiedad que ha cambiado.} \\
      \hline

      \textbf{Ejemplo} & \multicolumn{4}{|b{0.7\linewidth}|}{Evento que notifica del cambio de la propiedad \emph{Temperature}:\linebreak
      \usebox\propertychangedeventbox} \\

      \hline
  \end{tabular}

  \caption{Especificación del evento que notifica sobre el cambio de una propiedad del conocimiento.}
  \label{tab:especificacion-property-changed-integrationevent}
\end{table}


Para definir esta comunicación investigamos si había algún estándar equivalente a OpenAPI. Y así es, se llama AsyncAPI\footnote{Página oficial: \url{https://www.asyncapi.com/}}. Es un estándar para especificar la comunicación a través de eventos.Por desgracia, todavía no ha alcanzado el grado de madurez de su homónimo. No tiene el mismo número de herramientas disponible. Por ejemplo, no tiene un catálogo tan amplio de generadores de código que tiene el primero. Tampoco podemos tomar la aproximación de extraer la especificación a partir de una implementación existente.

Aun así, lo utilizaremos para describir nuestros eventos en un formato estándar. En el listing \ref{ls:asyncapi-propertychanged-integrationevent} hemos descrito el mensaje de la tabla \ref{tab:especificacion-property-changed-integrationevent}. Podemos apreciar que es muy parecido a la especificación del método get del listing \ref{ls:openapi-get}.

Aparece la descripción de la estructura del mensaje \texttt{PropertyChangedIntegrationEvent} y su documentación. La mayor diferencia es la mención del canal (el exchange en nuestro caso) y el método (subscribe). Esto indica que los consumidores podrán suscribirse a este evento a partir de este canal.

% TODO: Pintar bien los YAML.
\begin{lstlisting}[language={C++},caption={Ejemplo del evento de integración \emph{builder}.},captionpos=b, label=ls:asyncapi-propertychanged-integrationevent]
asyncapi: 2.4.0
info:
  title: Knowledge Service
  version: 1.0.0
  description: This service contains all the knowledge properties to inform the rest of the loop.
channels:
  AdaptionLoop.Knowledge:
    subscribe:
      message:
        $ref: '#/components/messages/PropertyChangedIntegrationEvent'
components:
  messages:
    PropertyChangedIntegrationEvent:
      description: >-
        Integration event about a change in an adaption property.
      payload:
        type: object
        properties:
          propertyName:
            type: string
            description: The name of the property that changed
\end{lstlisting}

Para implementar este patrón, nuestro conector estará compuesto por tres elementos: un publicador, el \foreign{english}{broker} y un consumidor. El funcionamiento será el siguiente: el servicio de conocimiento recibe una petición para actualizar una propiedad de adaptación. Si esta actualización se lleva a cabo, deberá crear el evento e invocar al publicador, que es un componente que se despliega con este servicio. El publicador recibirá el evento y lo publicará al \foreign{english}{broker} de mensajería en el \foreign{english}{exchange}.

El topic que usaremos es el nombre de la propiedad que ha cambiado.

El broker, que conoce todos los servicios que están subscritos a tema, lo añadirá en la cola de mensajería de cada uno de ellos. Los consumidores, desplegados en cada servicio cliente que se subscribe a estos mensajes, serán notificados de esto. Los procesarán en cuanto puedan. En la \textcolor{red}{figura X} mostramos cómo sería este nuevo conector.

\subsection{Peticiones asíncronas}

El último mecanismo de comunicación a diseñar son las \textbf{peticiones asíncronas}. Se trata de aquellas peticiones de trabajo que un microservicio del mismo nivel de la jerarquía le lanza a otro, sin esperar la respuesta. Como comentamos, tenemos dos casos en nuestra arquitectura que requieren de este patrón: la comunicación entre el módulo de análisis y el planificador, y entre el planificador y el ejecutor. Nos centraremos en el primero.

Recordemos que una vez se evalúan las reglas de adaptación, si alguna de ellas se ejecuta, propone un cambio en la configuración del sistema. El módulo de análisis recibirá esta propuesta y se la pasará al planificador. Este generará el plan de adaptación. Esta comunicación se realiza entre servicios en el mismo nivel de la jerarquía.

A la hora de escoger el mecanismo de comunicación, el razonamiento fue muy similar al de las notificaciones. Optamos por implementarlas usando un broker de mensajería, siguiendo el patrón de colas de trabajo. La arquitectura del comunicador es muy similar a la de las notificaciones: un publicador, un broker y un consumidor.

En lugar de ser una comunicación \foreign{english}{fanout} a través de un exchange, como en las notifcaciones, los mensajes van dirigidos a una cola concreta. El servicio consumidor cuenta con una cola de mensajería específica para las peticiones de trabajo. El publicador la conoce y, a través del broker, envía los mensajes allí. EL consumidor los irá recuperando y procesando en cuando esté disponile.

En la tabla \ref{tab:especificacion-system-configuration-change-request-box} presentamos la especificación de la petición asíncrona para solicitar un cambio de configuración de sistema. Vemos que es muy similar a \ref{tab:especificacion-property-changed-integrationevent}.

\newsavebox\systemconfigurationchangerequestbox
\begin{lrbox}{\systemconfigurationchangerequestbox}
  \begin{minipage}[t]{2in}
    \begin{verbatim}
{
  "Timestamp": "2022-06-19T16:38:30.6092751Z",
  "Symptoms":[
    {
      "Name": "temperature-lesser-than-cold-threshold",
      "Value": "true"
    }
  ],
  "ConfigurationRequests":  [
    {
      "ServiceName": "Climatisation.AirConditioner.Service",
      "IsDeployed": true,
      "ConfigurationProperties": [
        {
          "Name": "Mode",
          "Value": "Heating"
        }
      ],
      "Bindings": []
    }
  ]
}
        \end{verbatim}
  \end{minipage}
\end{lrbox}

\begin{longtable}{|m{2cm}|m{2.3cm}|m{10cm}|b{0.85cm}|b{2.75cm}|}
  \hline

  \textbf{Nombre} & \multicolumn{2}{|b{0.37\linewidth}|}{\emph{SystemConfigurationChangeRequest}} & \textbf{Cola} & \emph{AdaptionLoop.Planification.Requests}  \\
  \hline

  \textbf{Descripción} & \multicolumn{4}{|b{0.82\linewidth}|}{Petición que representa una propuesta de cambio de la configuración del sistema.} \\
  \hline

  \textbf{Propiedades}
    & \emph{Timestamp} & \multicolumn{3}{|m{0.67\linewidth}|}{Fecha y hora de la petición de cambio.} \\
    \cline{2-5}
    & \emph{Symptoms} & \multicolumn{3}{|m{0.67\linewidth}|}{Colección de síntomas que han desencadenado la petición de cambio.} \\
    \cline{2-5}
    & \emph{Configuration Requests} & \multicolumn{3}{|m{0.67\linewidth}|}{Colección peticiones de configuración de la propuesta de cambio.

    A su vez, está compuesto por:
    \begin{itemize}
      \item \textbf{\emph{ServiceName}}: Identificador del servicio cuya configuración queremos cambiar.
      \item \textbf{\emph{IsDeployed}}: Indica si el servicio debe estar desplegado o no en la siguiente configuración.
      \item \textbf{\emph{Bindings}}: Colección de conexiones que indican a qué servicios debe estar conectado (o no) este servicio en la siguiente configuración.
      \item \textbf{\emph{ConfigurationProperties}}: Colección de pares clave-valor que representan valores de configuración que queremos actualizar.
    \end{itemize}} \\
  \hline

  \textbf{Ejemplo} & \multicolumn{4}{|b{0.82\linewidth}|}{Solicitud de cambio de configuración para cambiar el modo de un aire acondicionado a modo calefacción (\emph{heating}). Fue desencadenada porque la temperatura es menor que un umbral determinado:\linebreak
  \usebox\systemconfigurationchangerequestbox} \\

  \hline

  \caption{Especificación de las peticiones de cambio de configuración del sistema.}
  \label{tab:especificacion-system-configuration-change-request-box}
\end{longtable}

Respecto a la especificación con AsyncAPI, las peticiones asíncronas no están soportadas todavía. El grupo está todavía estudiando cómo implementarlas. \footnotetext{Discusión disponible en: \url{https://github.com/asyncapi/spec/pull/594}}. Está propuesta para incluirla en la versión 3.0.0 de la especificación. Como mencionamos anteriormente, el estándar todavía es muy joven y tiene trabajo por delante.

En cuanto a sus componentes, el conector seguiría la siguiente arquitectura: \textcolor{red}{dibujo de arquitectura}.

\section{Diseño final}

Añadir diagrama con el diseño final, mostrando el diseño de los componentes con todos los conectores.
